<?phpConfigure::load('Taggable.config');class TaggableHelper extends AppHelper {	public $name = 'Taggable';	public $helpers = array(		'Html', 		'Form', 	);	public function beforeRender($writeFile, $options = array()) {		$this->Html->css('Taggable.style', null, array('inline' => false));		return parent::beforeRender($writeFile, $options);	}	/** * Outputs a version of the tag input, but wrapped in a form element to make it stand alone * * @param string $model The model related to the tags * @param array $options Options based on the input method options * @return string; **/	public function form($model, $options = array()) {		$options['form'] = true;		return $this->input($model, $options);	}		/** * Outputs a form input for entering tags associated with a model * * @param string $model The model name of the associated model * @param array $options * 		- form: Boolean to wrap the input in a form tag * 		- id: Includes an additional model id (Useful if form is true) * 		- tags: An array of existing tags (Most times this will be auto-set by the TaggableBehavior) *		- legend: The legend to be written across the tags input * * @return string; **/	public function input($model, $options = array()) {		$this->Html->script('Taggable.form', array('inline' => false));		$options = array_merge(array(			'form' => false,			'id' => false,			'tags' => array(),			'legend' => 'Tags',		), $options);		extract($options);		$wrapClass = 'taggable-tags-input';		$out = '';		if (empty($tags)) {			if ($this->Html->value("$model.taggable_tags")) {				$tags = $this->Html->value("$model.taggable_tags");			} else if ($this->Html->value('Tag')) {				$tags = array();				if (!empty($this->request->data['Tag']['Tag'])) {					$tags = $this->request->data['Tag']['Tag'];				} else {					foreach ($this->request->data['Tag'] as $k => $tag) {						$tags[$tag['id']] = $tag['tag'];					}				}			}		}		// Outputs tags input		$options = array(			'type' => 'text', 			'label' => 'Separate tags with commas',			'placeholder' => '(ie: tag 1, tag 2, tag 3)',		);		if (!empty($class)) {			$options = $this->Html->addClass($options, $class);		}		if (!empty($form)) {			$options = $this->Html->addClass($options, 'input-append', 'div');			$options['after'] = $this->Form->submit('Add Tags', array('div' => false));		}		$out .= $this->Form->input(Configure::read('Taggable.save_field'), $options);		// Outputs existing tags a checkbox list		if (!empty($tags)) {			if (isset($tags[0]['id'])) {				$newTags = array();				foreach ($tags as $tag) {					$newTags[$tag['id']] = $tag['tag'];				}				$tags = $newTags;			}			$out .= $this->Form->input('Tag', array(				'hiddenField' => false,				'options' => $tags,				'multiple' => 'checkbox', 				'label' => false, 				'value' => array_keys($tags),	//selected				'div' => $wrapClass . '-checkboxes',			));		}		if (!empty($legend)) {			$out = $this->Html->tag('legend', $legend) . $out;		}				$out = $this->Html->tag('fieldset', $out);		if (!empty($id)) {			$out .= $this->Form->hidden('id', array('value' => $id));		}		// Wraps output in a form		if (!empty($form)) {			$formOpen = $this->Form->create($model, array('action' => 'edit'));			$formClose = $this->Form->end();			$out = $formOpen . $out . $formClose;		}		return $this->Html->div($wrapClass, $out);	}		public function tag($text, $options = array()) {		$options = array_merge(array(			'tag' => 'span',			'x' => null,			'url' => null,			'class' => 'taggable-tag',		), $options);		extract($options);		$out = $text;		debug(compact('text'));		if ($url) {			$out = $this->Html->link($out, $this->_getTagUrl($text, $url));		}		if ($x) {			$out .= $this->_getXLink($x);		}		return $this->Html->tag($tag, $out, compact('class'));	}		public function resultTagList($result = null, $options = array()) {		$tags = !empty($result['taggable_tags']) ? $result['taggable_tags'] : array();		return $this->tagList($tags, $options);	}	public function tagList($tags = null, $options = array()) {		if (empty($tags)) {			return '';		}				$out = '';		foreach ($tags as $tag) {			if (isset($tag['tag'])) {				$tag = $tag['tag'];			}			$options['class'] = 'taggable-tags-list-item taggable-tag';			debug(compact('tag', 'options'));			$out .= $this->tag($tag, $options);		}		return $this->Html->tag('div', $out, array('class' => 'taggable-tags-list'));	}		public function cloud($tagCount, $options = array()) {		if (empty($tagCount)) {			return false;		}		$minFontSize = 10;		$maxFontSize = 36;		$fontUnit = 'px';		$min = min($tagCount);		$max = max($tagCount);		$passTag = !empty($this->request->named['tag']) ? $this->request->named['tag'] . ',' : '';				$out = '';		foreach ($tagCount as $tag => $count) {			if ($max == $min || $count == $min) {				$fontSize = $minFontSize;			} else {				$fontSize = ((($maxFontSize - $minFontSize) * ($count - $min)) / ($max - $min)) + $minFontSize;			}			$out .= $this->Html->link($tag, array('tag' => $passTag . $tag), array(				'class' => 'tag',				'style' => 'font-size:' . $fontSize . $fontUnit,				'title' => 'Found ' . $count . ' Tagged as "' . $tag . '"',			));		}		return $this->Html->div('tags-cloud', $out);	}		/** * Generates a url including the current tag * * @param string $tag The current tag * @param string|array|bool $url The url. If true it will grab the current url * @return string|array; **/	private function _getTagUrl($tag, $url = true) {		if ($url === true) {			$url = $this->_currentUrl();		}		$slug = Inflector::slug($tag);		if (is_array($url)) {			$url['tag'] = $slug;		} else {			$url .= '/tag:' . $slug;		}		return $url;	}/** * Returns the link to remove a tag from the current url * * @param array $url The given url array * @return string; **/	private function _getXLink($url = array()) {		if (!$url) {			return '';		}				if ($url === true || $url == 'remove') {			$url = array('tag' => false) + $this->_currentUrl();					}		return $this->Html->link('&times;', $url, array('escape' => false));	}	/** * Returns the current url of the page * * @return array; **/	private function _currentUrl() {		$url = Router::parse($this->request->url);		if (!empty($url['pass'])) {			$url['?'] = $url['pass'];			unset($url['pass']);		}		if (!empty($url['named'])) {			$url = $url['named'] + $url;			unset($url['named']);		}				return $url;	}}